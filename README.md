# logicmagent
# Professor
توصيف الحالة : كلاس للكرة الحديدية و كلاس للمغناطيس و كلاس  الهدف و 
كلاس  لتنفيذ اللعبة و رسم الرقعة 
nxn 
و كل مكان في الرقعة يمكن تمثيله بكرة او مغناطيس او هدف 
و تعتمد اللعبة على تحريك المغناطيس لجذب  او نفر الكرات الحديدية حسب نوع المغناطيس بهدف ايصالها للاهداف 

فصاء الحالة : هو ليستا تشمل جميع الرقع و كل رقعة تكون ممثلة دخل 
json
و هو ايضا مجموعة كل الحالات الناتجة عن تحريك المغناطيس

الحالة الابتدائية: تبدا بمغناطيس او مغناطيسيين داخل الرقعةو تكون الرقعة تحوي ايضا على كرات حديدية و مغناطيس و اهداف في اماكن معينة في الرقعة يتم تحديديها مسبقا

العمليات و الاجراءات: تابع لتحريك المغناطيس و تابع لتطبيق التاثير المغناطيس على الكرة الحديدية بجذب او نفر افقيا او شاقوليا و تابع لجذب الكرة في حال كان المغناطيس موجب و تابع اخر لنفر الكرة في حال كان المغناطيس سالب
و تابع للتحقق من الفوز و تابع للتحقق من ان الاهداف قد تمت تعبئتها

الحالة النهائية:  و هي الفوز بلعبة اي وضع جميع الكرات الحديدية و المغانط  في الاهداف و يخسر الاعب اذا لم يحقق ذلك

DFS بنية المعطيات Stack
BFS بنية المعطيات QUEUE

الية الحل :  نقوم بتخزين احداثيات المغناطيس الاولية داخل بنية المعطيات و اذا كان يوجد مغناطيس ثاني نضع شرط 
self.magnet[1].x if len(self.magnets) >1 else None
و نضع ليستا visited لعدم تكرار الزيارا و يفحص اذا الخليلة مزارة او لا و اذا ليست مزارة يتم اضافتها على اليستا لعدم زيارتها 
و من ثم نستدعي تابع لتحريك المغناطيس الاول و لتحريك المغنا
يس الثاني يفحص اذا كان موجود ام لا
 ثم نستدعي تابع لتحقق من الفوز 
 و ليتحرك المغناطيس في جميع الاتجاهات في الرقعة 
 نضع ليستاالاتجاهات
diraction = [(1,0),(-1,0),(0 , 1),(0,-1)]
و نضع حلقة forللمرور على هذه اليستا
و نضع dx , dy
لحساب الحركة الجديدة
و بنفس الطريقة بلنسبة للمغناطيس الثاني


الحل هو تخزين خطوات الحل خطوة بخطوة لكل مغناطيس و يتم تخزينه في ليستا path و نضغها بعد التحقق من تابع الفوز و نخزنها في ليسا فارغة للطباعتها
و اظهار رسالة فوز على الواجهة

